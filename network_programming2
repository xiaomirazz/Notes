服务器程序规范：
1-linux服务器程序一般以后台进程形式运行，又称守护进程。
2-linux服务器通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器，大部分后台进程都在
  /var/log目录下有自己的日志目录。
3-linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户。
4-linux服务器程序通常是可配置的，配置在/etc下面。
5-linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。如syslogd的文件是
  /var/run/syslogd/pid
6-linux服务器程序一般要考虑系统资源和限制，以预测自身能够承受多大的负荷，比如进程可用文件描述符总数和内存总量等。


Linux提供syslogd和rsyslogd（升级版）来处理系统日志。
rsyslogd既可以接收用户进程输出的日志，又能接收内核日志。
用户通过调用syslog函数生成系统日志，该函数将日志输出到一个unix本地域socket类型的文件/dev/log中，rsyslogd则监听该文件
  以获取用户进程的输出。
内核日志在老的系统上则是通过另外一个守护进程rklogd来管理的。rsyslogd利用额外的模块实现了相同的功能。
内核日志通过printk等函数打印到内核的环状缓存中，环状缓存内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。
rsyslogd守护进程在接收到用户或者内核进程的输入日志后会把他们输出到某些特定的日志文件。如调试信息/var/log/debug
  普通信息/var/log/messages，内核保存至/var/log/kern.log
具体对rsyslogd的配置在/etc/rsyslog.conf中。


void syslog(int priority,const char* msg);
应用程序使用syslog与rsyslogd守护进程通信。

void openlog(const char* ident,int logopt,int facility)
可以改变syslog的默认输出方式，ident指定的字符串会被添加到日志信息的日期和时间后，logopt对后续行为进行配置，facility改变syslog
  函数中的默认设施值。

int setlogmask(int maskpri);
过滤日志。

void closelog();
关闭日志功能。

int getrlimit(int resource,struct rlimit *rlim);
取系统资源限制
int setrlimit(int resource,const struct rlimit *rlim);
设定系统资源限制
resource为资源类型，rlim是资源限定结构体指针
struct rlimit{
  rlim_t rlim_cur;软限制 
  rlim_t rlim_max;硬限制
};


linux web服务根目录一般在/var/www/
char* getcwd(char* buf,size_t size);
获取当前进程工作目录，buf指向的内存用于存储当前的绝对路径名，size为大小
int chdir(const char* path);
改变进程工作目录，path指定要切换的目录路径
int chroot(const char* path);
path指定要切换到的目标根目录


将服务器程序以守护进程的方式运行
bool daemonize()
{
  /*创建子进程，关闭父进程，这样可以使程序在后台运行*/
  pid_t pid = fork();
  if(pid<0)
  {
    return false;
  }
  else if(pid>0)
  {
    exit(0);
  }
  
  umask(0) //设置文件权限掩码
  
  /*创建新的会话，设置本进程为进程组的首领*/
  pid_t sid = setsid();
  if(sid<0)
  {
    return false;
  }
  
  /*切换工作目录*/
  if((chdir("/"))<0)
  {
    return false;
  }
  /*关闭标准输入输出*/
  close(STDIN_FILENO);
  close(STDOUT_FILENO);
  close(STDERR_FILENO);
  
  /*定向新的输入输出*/
  open("/dev/null",O_RDONLY);
  open("/dev/null",O_RDWR);
  open("/dev/null",O_RDWR);
  return true;
}

实际上linux也提供了api
int daemon(int nochdir,int noclose);
nochdir标记是否改变工作目录，传0则该表到根目录。
noclose参数为0时，标准输入，标准输出和标准错误输出都重定向到/dev/null.
成功返回0，失败返回-1并置errno

  
}

