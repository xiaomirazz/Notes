int close(int fd)并非总是关闭一个连接，而是将fd的引用技术减1.
当fd的引用计数为0时，才真正关闭连接.

在多进程程序中，一次fork会使父进程中的socket引用计数加1，因此我们必须在父进程和子进程中都调用close才能将连接关闭.

int shutdown(int sockfd,int howto)用来终止连接，howto可以决定关闭读或写，或者都关闭。成功返回0.

通用数据读写函数：
#include<sys/socket.h>
ssize_t recvmsg(int sockfd,struct msghdr* msg,int flags);
ssize_t sendmsg(int sockfd,struct msghdr* msg,int flags);

msghdr结构：
struct msghdr
{
  void *msg_name;   //socket地址
  socklen_t msg_namelen;  //socket地址长度
  struct iovec* msg_iov;    //分散的内存块
  int msg_iovlen;   //分散内存块的数量
  void* msg_control;    //指向辅助数据的起始位置
  socklen_t msg_controllen;     //辅助数据的大小
  int msg_flags;      //复制函数中的flags参数，并在调用过程中更新
};
msg_name指向一个socket地址结构变量，指定通信对方的socket地址。对于TCP该成员必须设置为NULL。
msg_iov是iovec结构体类型的指针。
struct iovec
{
  void *iov_base;
  size_t iov_len;
};

int sockatmark(int sockfd);检测sockfd是否处于带外标记，如TCP紧急标志。

int getsockname(int sockfd,struct sockaddr* address,socklen_t* address_len);
获取sockfd对应的本端socket地址，并将其存储在address参数指定的内存中，成功返回0.
int getpeername(int sockfd,struct sockaddr* address,socklen_t* address_len);
获取sockfd对应的远端socket地址，其他参数同上。

int getsockopt(int sockfd,int level,int option_name,void* option_value,socklen_t* restrict option_len);
int setsockopt(int sockfd,int level,int option_name,const void* option_value,socklen)t option_len);
专门用来读取和设置socket文件描述符的属性方法。
服务器监听时一些socket是由accept返回，这样如果需要返回的socket有某些选项，则应当对监听socket设置那些选项，这样accept的
连接socket会自动继承这些选项。
对于客户端，这些socket选项应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手完成。
几个重要选项：
SO_REUSEADDR：用来强制使用被处于TIME_WAIT状态的连接占用的socket地址。设置过后，即使sock处于TIME_WAIT状态，与之绑定的socket
              地址也可以立即被重用。此外我们也可以通过修改/proc/sys/net/ipv4/tcp_tw_recycle参数来快速回收被关闭的socket。
SO_RCVBUF和SO_SNDBUF：分别表示TCP接受缓冲和发送缓冲。当我们用来设置TCP的接受和发送缓冲区大小的时候，系统都将其加倍并不得
              小于某个最小值（接收256，发送2048）此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和
              /proc/sys/net/ipv4/tcp_wmem来强制TCP接收和发送缓冲区的大小没有限制。
SO_RCVLOWAT和SO_SNDLOWAT：分别表示TCP接收缓冲区和发送缓冲区的低水位标记。它们一般被IO复用系统调用用来判断socket是否可读写。
              当TCP接收缓冲区刻度数据的总数大于低水位标记的时候，IO复用系统调用将通知应用程序可以从对应的socket上读取数据。
              当TCP发送缓冲区的空闲空间大于其低水位标记的时候，IO复用系统调用将通知应用程序可以往对应的socket上写入数据。
              默认情况下，这两个标记都为1.
SO_LINGER:用于控制close系统调用在关闭TCP连接时的行为。默认情况下，当我们close一个socket时，close将立即返回，TCP模块负责把该
              socket对应的TCP发送缓冲区中残留的数据发送给对方
              
网络信息API:
struct hostent* gethostbyname(const char* name);
根据主机名称获取主机的完整信息。通常先在/etc/hosts配置文件中查找主机，没找到再去找DNS服务器。
struct hostend* gethostbyaddr(const void* addr,size_t len,int type);
根据IP地址获取主机的完整信息。
struct hostent
{
  char* h_name;主机姓名
  char** aliases;主机别名列表
  int h_addrtype;地址类型
  int h_length;地址长度
  char** h_addr_list;按网络字节序列出的主机IP地址列表
};

struct servent* getservbyname(const char* name,const char* proto);
根据名称获取某个服务的完整信息。
struct servent* getservbyport(int port,const char* proto);
根据端口号获取某个服务的完整信息。
proto参数指定服务类型tcp为流服务，udp为数据报服务。
他们都是通过读取/etc/services文件来获取服务的信息的。
struct servent
{
  char* s_name;
  char** s_aliases;
  int s_port;
  char* s_proto;
};
以上4个函数都是不可重入的，netdb.h给出了可重入版本原名后面加_r

int getaddrinfo(const char* hostname,const char* service,const struct addrinfo* hints, struct addrinfo** result);
能通过主机名获得IP地址，也能通过服务名获得端口号
struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  char* ai_canonname;
  struct sockaddr* ai_addr;
  struct addrinfo* ai_next;
};
此函数将隐式地分配堆内存，所以getaddrinfo调用结束后，我们必须调用void freeaddrinfo(struct addrinfo* res)释放内存;

int getnameinfo(const struct sockaddr* sockaddr,socklen_t addrlen,char* host,socklen_t hostlen,char* serv,socklen_t servlen,
  int flags);
能通过socket地址同时获得以字符串表示的主机名和服务名。

const char* gai_strerror(int error);
可以把错误码转换成字符串形式。

--------------------------------------------------------------------------------------------------------------------------
高级IO函数
int pipe(int fd[2]);
pipe函数可用于创建一个管道，以实现进程间通信。成功返回1。
fd[0]和fd[1]构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且fd[0]只能从管道读，fd[1]只能用于往管道写入。不能反过来。
如果要实现双向的数据传输，就应该使用两个管道。默认情况下，这一对文件描述符是阻塞的。此时如果我们用read读一个空管道则read
将被阻塞，直到管道内有数据可读。如果用write往一个满的管道中写入数据，则write将被阻塞，直到管道有空间可用。
int socketpair(int domain,int type,int protocol,int fd[2]);
fd两个描述符都是既可读又可写的。

int dup(int file_descripter);
创建一个新的文件描述符，该文件描述符和f_d指向相同的文件、管道或者网络连接。dup返回的文件描述符总是取当前可用的最小值。
int dup2(int file_des_one,int file_des_two);
dup2和dup类似，不过它返回第一个不小于file_des_two的整数值。
这两个函数创建的文件描述符并不继承原文件描述符的属性。

CGI服务器基本原理：
int connfd = accept();
if(connfd<0)
return;
else
{
  close(STDOUT_FILENO);
  dup(connfd);
  printf("abcd\n");
  close(connfd);
}
用connfd取代了服务器的标准输出。

ssize_t readv(int fd,const struct iovec* vector,int count);
ssize_t writev(int fd,const struct iovec* vector,int count);
read从文件描述符读到分散的内存中，write将多块分散内存写入到文件描述符中。

ssize_t sendfile(int out_fd,int in_fd,off_t* offset,size_t count);
在两个文件描述符之间直接传递数据，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率更高。成功返回字节数。

void* mmap(void *start,size_t length,int prot,int flags,int fd,off_t offset);
start允许用户指定一个特定的地址作为内存的起始地址，如果设置成NULL则系统自动分配一个地址。length参数指定内存段的长度。
prot参数用来设置内存段的访问权限。flags参数控制内存段内容被修改后程序的行为。

ssize_t splice(int fd_in,loff_t* off_in,int fd_out,loff_t* off_out,size_t len,unsigned int flags);
用于在两个文件描述符之间的移动数据。

ssize_t tee(int fd_in,int fd_out,size_t len,unsigned int flags);
用于在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，后续还可以继续读。

int fcntl(int fd,int cmd,...);
提供了对文件描述符的各种操作，另外一个常见的控制文件描述符属性和行为的是ioctl，而且ioctl比fcntl能够执行更多的控制。
但是对于控制文件描述符常用的属性和行为，fcntl函数式由posix规范制定的首选方法。
int munmap(void* start,size_t length);
