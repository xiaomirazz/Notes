设计原则1
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

设计原则2
针对接口编程，而不是针对实现编程。

设计原则3
多用组合，少用继承

----------------------------------------------------------------------------------------------------
策略模式：
定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
示例：
public abstract class Duck{
  FlyBehavior flyBehavior;
  QuackBehavior quackBehavior;
  
  public void setFlyBehavior(FlyBehavior fb){
    flyBehavior = fb;
  }
  
  public void setQuackBehavior(QuackBehavior qb){
    quackBehavior = qb;
  }
  
  public Duck(){
  }
  
  public abstract void display();
  
  public void performFly(){
    flyBehavior.fly();
  }
  
  public void performQuack(){
    quackBehavior.quack();
  }
  
  public void swim(){
    System.out.println("All Ducks can swim!!!");
  }
}

public interface FlyBehavior{
  public void fly();
}

public class FlyWithWings implements FlyBehavior{
  public void fly(){
    System.out.println("I'm flying!!!");
  }
}

public class FlyNoWay implements FlyBehavior{
  public void fly(){
    System.out.println("I can't fly...");
  }
}

public interface QuackBehavior{
  public void quack();
}

public class Quack implements QuackBehavior{
  public void quack(){
    System.out.println("Quack");
  }
}

public class MuteQuack implements QuackBehavior{
  public void quack(){
    System.out.println("zzzzzzz");
  }
}

public class ModelDuck extends Duck{
  public ModelDuck(){
    flyBehavior = new FlyNoWay();
    quackBehavior = new Quack();
  }
  
  public void display(){
    System.out.println("I'm a model duck!!!");
  }
}

public class DuckSimulator{
public static void main(string[] args){
    Duck model = new ModelDuck();
    model.performFly();
    model.setFlyBehavior(new FlyRocketPowered());
    model.performFly();
  }
}
-------------------------------------------------------------------------------------------------------
设计原则：为了交互对象之间的松耦合设计而努力。

观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
import java.util.Observable;
import java.util.Observer;

public class WeatherData extends Observable{
  private float temperature;
  private float humidity;
  private float pressure;
  
  public WeatherData(){
  }
  
  public void measurementsChanged(){
    setChanged();
    notifyObservers();
  }
  
  public void setMeasurements(float temperature,float humidity,float pressure){
    this.temperature = temperature;
    this.humidity = humidity;
    this.pressure = pressure;
    measurementsChanged();
  }
  
  public float getTemperature(){
    return temperature;
  }
  
  public float getHumidity(){
    return humidity;
  }
  
  public float getPressure(){
    return pressure;
  }
}

public class CurrentConditionsDisplay implements Observer,DisplayElement{
  Observable observable;
  private float temperature;
  private float humidity;
  
  public CurrentConditionsDisplay(Observable observable){
    this.observable = observable;
    observable.addObserver(this);
  }
  
  public void update(Observable obs,Object arg){
    if(obs instanceof WeatherData){
      WeatherData weatherData = (WeatherData)obs;
      this.temperature = weatherData.getTemperature();
      this.humidity = weatherData.getHumidity();
      display();
    }
  }
  
  public void display(){
    System.out.println("Current conditions:"+temperature+"F degrees and "+humidity+"% humidity");
  }
}

Observable有局限性，首先它是个类，如果我们的新类需要从另一个父类继承特性，这样就不能实现了。其次，observable还有
被保护的方法如setChanged。我们无法改变其实现。

如果可以最好实现自己的观察者模式
-------------------------------------------------------------------------------------------------------------------
设计原则：类性该对扩展开放，对修改关闭。

装饰者模式
装饰者和被装饰者有相同的超类型。
你可以用一个或者多个装饰者包装一个对象。
既然装饰者和被装饰者对象具有相同的超类型，所以在任何需要原始对象的场合，可以用装饰过的对象代替它。
装饰者可以在所委托被装饰者的行为之前或之后加上自己的行为，以达到特定的目的。
对象可以再任何时候被装饰，所以可以再运行时动态地、不限量地用你喜欢的装饰者来装饰对象。

定义：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

public abstract class Beverage{
  String description = "Unknown Beverage";
  public String getDescription(){
    return description;
  }
  public abstract double cost();
}

public abstract class CondimentDecorator extends Beverage{
  public abstract String getDescription();
}

public class Espresso extends Beverage{
  public Espresso(){
    description = "Espresso";
  }
  
  public double cost(){
    return 1.99;
  }
}

public class Mocha extends CondimentDecorator{
  Beverage beverage;
  
  public Mocha(Beverage beverage){
    this. beverage = beverage;
  }
  
  public String getDescription(){
    return beverage.getDescription()+"Mocha";
  }
  
  public double cost(){
    return .20+beverage.cost();
  }
}

public class StarBuzzCoffee{
  public static void main(String args[]){
    Beverage beverage2 = new DarkRoast();
    beverage2 = new Mocha(beverage2);
    beverage2 = new Mocha(beverage2);
    beverage2 = new Whip(beverage2);
    System.out.println(beverage2.getDescription()+"$"+beverage2.cost());
  }
}

Java io库用了大量的装饰者模式


------------------------------------------------------------------------------------------------------------------
工厂模式

public class SimplePizzaFactory{
  public Pizza createPizza(String type){
    Pizza pizza = null;
    
    if(type.equals("cheese")){
      pizza = new CheesePizza();
    }
    else if()...
  }
}

public class PizzaStore{
  SimplePizzaFactory factory;
  public PizzaStore(SimplePizzaFactory factory){
    this.factory = factory;
  }
  public Pizza orderPizza(String type){
    Pizza pizza;
    
    pizza = factory.createPizza(type);
    
    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();
    return pizza;
  }
}
