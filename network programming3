高性能服务器程序框架

IO处理单元   请求队列   逻辑单元（多个）   请求队列   网络存储单元

IO处理单元是服务器管理客户连接的模块。它通常完成以下工作：等待并接受新的客户连接，接受客户数据，将服务器响应数据返回给客户端。
  但是接受的数据不一定在IO处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。对于一个服务器集群来说，
  IO处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。

一个逻辑单元通常是一个进程或者线程。它分析并处理客户数据，然后将结果传递给IO处理单元或者直接发给客户端。对服务器集群而言，一个
  逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户人物的并行处理。
  
网络存储单元可以使数据库，缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登陆服务就不用这个单元。

请求队列是各单元之间通信方式的抽象。

------------------------------------------------------------------------------------------------------------------------------
IO模型

socket的基础API中，可能被阻塞的系统调用包括accept、send、recv、和connect。

IO复用函数（select、poll、epoll_wait）他们本身是阻塞的，它们能够提高程序效率的原因在于它们具有同时监听多个IO事件的能力。

我们只有在事件已经发生的情况下去操作非阻塞IO才能提高程序的效率。
-------------------------------------------------------------------------------------------------------------------------------
Reactor模式

它要求主线程只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程。除此外，主线程不做任何其他实质性的工作。
读写数据，接收新连接，以及处理客户请求均在工作线程中完成。

使用同步IO模型（epool_wait）实现reactor模式的工作流程是：
1、主线程往epoll内核事件中注册socket上的读就绪事件。
2、主线程调用epoll_wait等待socket上有数据可读。
3、当socket上有数据可读的时候，epoll_wait通知主线程。主线程将socket可读事件放入请求队列。
4、睡眠在请求队列上的某个工作线程被唤醒，它从socket读入数据，并处理客户请求，然后往epoll内核时间表中注册该socket上的写就绪事件。
5、主线程调用epoll_wait等待socket可写。
6、当socket可写的时候，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
7、睡眠在请求队列上的某个线程被唤醒，它往socket上写入服务器处理客户请求的结果。

------------------------------------------------------------------------------------------------------------------------------
Proactor模式

将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

使用异步IO模型（aio_read和aio_read为例）实现的工作流程。

1、主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置。以及操作完成如何通知应用 程序。
2、主线程继续处理其他逻辑。
3、当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。
4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册
  socket上的写完成事件并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
5、主线程继续处理其他逻辑。
6、当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
7、应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

------------------------------------------------------------------------------------------------------------------------------
模拟Proactor模式

工作流程：
1、主线程往epoll内核事件表中注册socket上的读就绪事件。
2、主线程调用epoll_wait等待socket上有数据可读。
3、当socket有数据可读的时候，epoll_wait通知主线程。主线程从socket循环读取数据，指导没有更多数据可读，然后将读取到的数据封装
成一个请求对象插入请求队列。
4、睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。
5、主线程调用epoll_wait等待socket可写。
6、当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

------------------------------------------------------------------------------------------------------------------------------
简单的有限状态机
state_machine()
{
  state cur_state = typeA;
  while(cur_state != typeC)
  {
    package pack = getNewPackage();
    switch(cur_state)
    {
      case typeA:
        process_package_state_A(pack);
        cur_state = typeB;
        break;
      case typeB:
        process_package_state_B(pack);
        cur_state = typeC;
        break;
    }
  }
}

----------------------------------------------------------------------------------------------------------------------------
HTTP请求的读取和分析

#define BUFFER_SIZE 4096

enum CHECK_STATE{CHECK_STATE_REQUESTLINE=0,CHECK_STATE_HEADER};

enum LINE_STATUS{LINE_OK = 0, LINE_BAD,LINE_OPEN};

enum HTTP_CODE{NO_REQUEST,GET_REQUEST,BAD_REQUEST,BAD_REQUEST,FORBIDDEN_REQUEST,INTERNAL_ERROR,CLOSED_CONNECTION};

static const char* szret[] = {"I get a correct result\n","Something wrong\n"};

LINE_STATUS parse_line(char* buffer,int& checked_index,int& read_index)
{
  char temp;
  for(;checked_index < read_index; ++checked_index)
  {
    temp = buffer[checked_index];
    if(temp == '\r')
    {
      if((checked_index +1) == read_index)
      {
        return LINE_OPEN;
      }
      else if(buffer[checked_index + 1] =='\n')
      {
        buffer[checked_index++] = '\0';
        buffer[checked_index++] = '\0';
        return LINE_OK;
      }
      return LINE_BAD;
    }
    else if(temp == '\n')
    {
      if((checked_index>1)&&buffer[checked_index - 1]=='\r')
      {
        buffer[checked_index -1] = '\0';
        buffer[checked_index++] = '\0';
        return LINE_BAD;
      }
    }
    return LINE_OPEN;
  }
}


HTTP_CODE parse_requestline(char* temp,CHECK_STATE& checkstate)
{
  char* url = strpbrk(temp,"\t");
  if(!url)
  {
    return BAD_REQUEST;
  }
  
  *url++ = '\0';
  
  char* method = temp;
  if(strcasecmp(method,"GET") == 0)
  {
    printf("GET!")；
  }
  else
  {
    return BAD_REQUEST;
  }
  
  url+= strspn(url,"\t");
  char* version = strpbrk(url," \t");
  if(!version)
  {
    return BAD_REQUEST;
  }
  
  *version++ = '\0';
  version += strspn(version," \t");
  
  if(strcasecmp(version,"HTTP/1.1")!=0)
  {
    return BAD_REQUEST;
  }
  
  if(strncasecmp(url,"http://",7) == 0)
  {
    url += 7;
    url = strchr(url,'/');
  }
  
  if(!url | url[0] !='/')
  {
    return BAD_REQUEST;
  }
  printf("the request url is %s\n",url);
  checkstate = CHECK_STATE_HEADER;
  return NO_REQUEST;
}

HTTP_CODE parse_headers(char* tmp)
{
  if(temp[0] == '\0')
  {
    return GET_REQUEST;
  }
  else if(strncasecmp(temp,"Host:",5)==0)
  {
    temp += 5;
    temp += strspn(temp,"\t");
    printf("the request host is:%s\n",temp);
  }
  else
  {
    printf("I can not handle this header\n");
  }
  return NO_REQUEST;
}

HTTP_CODE parse_content(char* buffer,int& checked_index,CHECK_STATE& checkstate, int& read_index,int& start_line)
{
  LINE_STATUS linestatus = LINE_OK;
  HTTP_CODE retcode = NO_REQUEST;
  while((linestatus = parse_line(buffer,checked_index,read_index))==LINE_OK)
  {
    char* temp = buffer+start_line;
    start_line = checked_index;
    switch(checkstate)
    {
      case CHECK_STATE_REQUESTLINE:
      {
        retcode = parse_requestline(temp,checkstate);
        if(retcode == BAD_REQUEST)
        {
          return BAD_REQUEST;
        }
        break;
      }
      case CHECK_STATE_HEADER:
      {
        retcode = parse_headers(temp);
        if(retcode == BAD_REQUEST)
        {
          return BAD_REQUEST;
        }
        else if(retcode == GET_REQUEST)
        {
          return GET_REQUEST;
        }
        break;
      }
      default:
      {
        return INTERNAL_ERROR;
      }
    }
  }
  if(linestatus == LINE_OPEN)
  {
    return NO_REQUEST;
  }
  else
  {
    return BAD_REQUEST;
  }
}

int main(int argc,char* argv[])
{
  if(argc <= 2)
  {
    printf("usage: %s ip_addres port_number\n",basename(argv[0]));
    return 1;
  }
  const char* ip=argv[1];
  int port= atoi(argv[2]);
  
  struct sockaddr_in address;
  bzero(&address,sizeof(address));
  address.sin_family = AF_INET;
  inet_pton(AF_INET,ip,&address.sin_addr);
  address.sin_port = htons(port);
  
  int listenfd=socket(PF_INET,SOCK_STREAM,0);
  assert(listenfd>=0);
  
  int ret = bind(listenfd,(struct sockaddr*)&address,sizeof(address));
  assert(ret != -1);
  
  ret = listen(listenfd,5);
  assert(ret != -1);
  
  strcut sockaddre_in client_address;
  socklen_t client_addrlength = sizeof(client_address);
  
  int fd = accept(listenfd,(struct sockaddr*)&client_address,&client_addrlength);
  
  if(fd<0)
  {
    printf("error");
  }
  else
  {
    char buffer[BUFFER_SIZE];
    memset(buffer,'\0',BUFFER_SIZE);
    int data_read = 0;
    int read_index = 0;
    int checked_index = 0;
    int start_line = 0;
    
    CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;
    while(1)
    {
      data_read = recv(fd,buffer+read_index,BUFFER_SIZE = read_index,0);
      if(data_read == -1)
      {
        printf("reading failed\n");
        break;
      }
      else if(data_read == 0)
      {
        printf("remote client has closed the connection\n");
        break;
      }
      read_index+=data_read;
      HTTP_CODE result = parse_content(bufer,checked_index,checkstate,read_index,start_line);
      if(result == NO_REQUEST)
      {
        continue;
      }
      else if(result == GET_REQUEST)
      {
        send(if,szret[0],strlen(szret[0],0));
        break;
      }
      else
      {
        send(fd,szret[1],strlen(szret[1]),0);
        break
      }
    }
    close(fd);
  }
  close(listenfd);
  return 0;
}

-----------------------------------------------------------------------------------------------------------------
提高服务器性能的其他建议

1池
2数据复制
3上下文切换
-------------------------------------------------------------------------------------------------------------------
第九章 io复用
-------------------------------------------------------------------------------------------------------------------
select
int select(int nfds,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval* timeout)

先说最后一个参数，它指定愿意等待的时间。
struct timeval
{
     long tv_sec;
     long tv_usec;
};
有3种情况:
timeout == NULL
永远等待。如果捕捉到一个信号则中断此无限期等待。当所指定的描述符中的一个已准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则select返回-1，errno设置为EINTR.
 
timeout->tv_sec = 0 && timeout->tv_usec = 0
完全不等待。测试所有指定的描述符并立即返回。这是得到多个描述符的状态而不阻塞select函数的轮询方法。
 
timeout->tv_sec != 0 || timeout->tv_usec != 0
 
等待指定的秒数和微秒数。
 
注意：
（1）千万不要混淆了timeout == NULL与timeout->tv_sec = 0 && timeout->tv_usec = 0这2种情况，结果截然不同。
（2）timeout->tv_sec != 0 || timeout->tv_usec != 0这种情况下，超时过后，就变成了
 timeout->tv_sec = 0 && timeout->tv_usec = 0。
 
中间的三个参数readfds,writefds和exceptfds是指向描述符集的指针。这三个描述符集说明了我们关心的可读、可写或处于异常条件的各个描述符。每个描述符放在一个fd_set数据类型中。这种数据类型为每一可能的描述符保持了一位。
 
对fd_set数据类型可以进行处理的是：分配一个这种类型的变量；将这种类型的一个变量赋予同类型的另一个变量；或对于这种类型的变量使用下列四个函数中的一个。
 
#include <sys/select.h>
int  FD_ISSET(int fd,fd_set *fdset);
void FD_CLR(int fd,fd_set *fdset);
void FD_SET(int fd,fd_set *fdset);
void FD_ZERO(int fd,fd_set *fdset);
 
这些接口可实现为宏或函数。具体意见就不多说了。
 
int select(int maxfdp1,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);
 
因为描述符编号从0开始，所以要在最大描述符编号值上加1.第一个参数实际上是要检查的描述符数（从描述符0开始）
select有三个可能的返回值。
（1）返回值-1表示出错。出错是有可能的，例如在所指定的描述符都没有准备好时捕捉到一个信号。在此种情况下，将不修改其中任何描述符集。
（2）返回值0表示没有描述符准备好。若指定的描述符都没有准备好，而且指定的时间已经超过，则发生此种情况。此时，所有描述符集皆被清0.
（3）正返回值表示已经准备好的描述符数。
 
注意红色部分，超时后，每次描述符集都需要重新设置。
 
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netdb.h>
int main(int argc,char *argv[])
{
 int listen_fd;
 int client_fd;
 socklen_t clt_len;
 struct sockaddr_in srv_addr;
 struct sockaddr_in clt_addr;
 int port;
 int ret;
 int len;
 int num;
 char recv_buf[1024];
 fd_set read_fds;
 struct timeval wait_time;
 if(argc != 2)
 {
  printf("Usage: %s port_name\n",argv[0]);
  return 1;
 }
 
 port = atoi(argv[1]);
 listen_fd = socket(PF_INET,SOCK_STREAM,0);
 if(listen_fd < 0){
  perror("cannot create socket");
  return 1;
 }
 memset(&srv_addr,0,sizeof(srv_addr));
 srv_addr.sin_family=AF_INET;
 srv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
 srv_addr.sin_port=htons(port);
 ret = bind(listen_fd,(struct sockaddr*)&srv_addr,sizeof(srv_addr));
 if(ret < 0)
 {
  perror("cannot bind the socket");
  return 1;
 }
 ret = listen(listen_fd,1);
 if(ret == -1)
 {
  perror("cannot listen the client connect request");
  close(listen_fd);
  return 1;
 }
    wait_time.tv_sec=0;
 wait_time.tv_usec=0;
 FD_ZERO(&read_fds);
 FD_SET(listen_fd,&read_fds);
  
 while(1)
 { 
     FD_ZERO(&read_fds);
     FD_SET(listen_fd,&read_fds);
   ret = select(listen_fd + 1,&read_fds,NULL,NULL,&wait_time);   
        if(ret > 0)
        {        
            if(FD_ISSET(listen_fd,&read_fds) > 0)
            {                 
                len = sizeof(clt_addr);
                client_fd = accept(listen_fd,(struct sockaddr*)&clt_addr,&len);
                if(client_fd < 0)
                {         
                    perror("cannot accept client connect request");
                    close(listen_fd);
                    return 1;  
                }
                while(1)
                {
                    FD_ZERO(&read_fds);
                    FD_SET(client_fd,&read_fds);    
                    if(select(client_fd + 1,&read_fds,NULL,NULL,&wait_time) > 0)
                    {                
                        if(FD_ISSET(client_fd,&read_fds) > 0)
                        {
                            len = read(client_fd,recv_buf,sizeof(recv_buf));
                            if(len > 0)
                            {
                                recv_buf[len] = 0;
                                printf("%s\n",recv_buf);
                                write(client_fd,recv_buf,len);
                            }
                            else
                            {
                                close(client_fd);
                                break;
                            }
                        }                   
                    }                   
                }           
               
           }     
                              
        } 
        
 }
}
