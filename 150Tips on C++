1-为了保证程序的可移植性能，要使用int main（）而不是void main（）

2-区分0的4种面孔
  整形0、空指针null、字符串结束标志\0、逻辑false。
  
3-避免那些由运算符引发的混乱
  if(value = 0)x      ---->   if(0 == value)
  & && | || 

4-对表达式运算顺序不要想当然
  不要吝啬使用括号来确定运算顺序。
  对于同一语句的估值问题，可以用变量来确定参数或运算数的值，避免出现意料之外的结果。
  
5-小心#define中的使用陷阱
  要有完备的括号
  使用宏时要保证参数不发生变化（++ --副作用）
  用大括号将宏所定义的多条表达式括起来
  
6-不要忘记指针变量的初始化
  避免访问野地址。
  
7-明晰逗号分隔表达式的奇怪之处
  表达1，表达2，表达3……表达n    表达式的值为表达n的值，之前的表达式保证执行

8-时刻提防内存溢出

9-拒绝晦涩难懂的函数指针

10-防止重复包含头文件
  #ifndef #define #endif
  名字定义为_PROJECT_PATH_FILE_H

11-优化结构体中元素的布局
  由于结构体内存对齐的问题，优化布局可以节省内存空间。
  #pragma pack（n）可以改变内存对齐的字节数

12-将强制转型减少到最少
  const_cast<T*>(a) 用于去除const、volatile和__unaligned
  dynamic_cast<T*>(a) 将a转化为T*类型的指针，向下安全，父类子类转化
  reinterpret_cast<T*>(a) 用于将一个类转化为不相关类
  static_cast<T*>(a) 将a的值转换为T类型
  
13-优先使用前缀操作符++ --
  前缀运算符不用构建临时对象，所以效率略优于后缀操作符
  
14-掌握变量定义的位置与时机
  优于构造和析构函数不可避免地会带来一些开销，建议在需要使用变量时再去定义。
  建议定义越local越好，尽量避免变量作用域的膨胀，减少变量名污染和调高代码阅读性。
  
15-小心typedef中的陷阱
  小心typedef与#define的区别，宏只替换一次，如果是指针切声明多个变量会有不同。宏只第一个变量为指针，typedef则可以多

16-尽量不要使用可变参数

17-慎用goto

18-提防隐式转换带来的麻烦

19-正确区分void和void*
  函数无返回值和无参时可以用void
  void*可以用于函数接收任意类型指针
  void*指向的内容不可以用++ --

20-明白在c++中如何使用c
  extern "C"

21-使用memxxx函数的时候要注意

22-尽量使用new delete代替malloc和free
  前两者为运算符，会调用构造函数和析构函数，new出异常可以调用new_handler
  后两者为函数，不会调用构造函数和析构函数
  
23-灵活地使用各种注释风格

24-尽量使用c++中的iostream

25-尽量使用c++的强制转换风格

26-尽量使用const enum和inline代替#define
  尽量把工作量交给编译器
  
27-用引用代替指针
  
28-new delete和new[] delete[]必须配对使用

29-内存分配方式

30-区分new的3中形态

31-new内存失败后的正确处理
  catch(std::bad_alloc& e)

32-了解new_handler的所作所为

33-借助工具监测内存泄露问题
  Rational Purify

34-小心翼翼地重载operator new和operator delete 
  重载的原因可能：更灵活地分配，改善效率，检测代码中的内存错误，获得内存使用的统计数据。
  如果重载了new就一定要记得重载一个对应的delete
  
35-用智能指针管理通过new出来的对象
  auto_ptr弊端：
    不可作为STL容器的元素
    缺少对动态而来数组的支持
    在复制的时候会发生所有权转移，旧指针对对象的管理移交给新指针
  
  Boost中有许多智能指针：shared_ptr unique_ptr（auto的boost版本） shared_array scoped_ptr scoped_array
  使用的规则
    1、smart_ptr<T>不同于T*
      smart_ptr<T>的真实身份其实是一个对象，一个管理动态分配的对象的对象，T*是个指针
      在创建时明确写出smart_ptr<T> t(new T)
      禁止将T*赋值给一个智能指针
      不要用xxx=NULL将只能指针置空，应该使用成员函数
    2、不要使用临时的smart_ptr<T>对象
      有资源泄露的风险

36-使用内存池技术提高内存申请效率与性能

37-明晰class与struct的区别
  class struct如果定义了构造函数就不能使用大括号初始化。
  class只有在成员变量都是public的时候才能用大括号初始化。
  以上变化在c++ 11标准中进行了统一。新标准中允许使用大括号初始化。
  
  class默认访问权限是private，struct是public。
  class默认继承方式为private，struct默认是public。

38-了解c++悄悄做的那些事
  class的三个不可逃避的部分：一个或者多个构造函数、一个析构函数、一个拷贝赋值运算符
  c++ 11新的标准，default和delete关键字可以决定是否使用默认的还是禁止生成。
  ~A() = default；默认析构函数
  A& operator=(const A&) = delete;禁止生成默认的赋值运算符。
  空类为1字节。
  
39-首选初始化列表实现类成员的初始化
  const成员变量只能用初始化列表来初始化而不能放在构造函数中进行赋值初始化。
  如果类B中含有A的成员变量，而A禁止了赋值操作，那么初始化A只能用初始化列表。
  初始化列表的初始化顺序和成员变量在类中的声明顺序相同。
  
40-明智地拒绝对象的复制操作
  把拷贝构造函数和赋值运算符改为private

41-自定义拷贝函数一定要小心
  浅拷贝（bitwise copy）当对象包含资源进行浅拷贝时，两个资源指针会指向同一资源。
  深拷贝就是把资源也复制一份出来，让两个对象指向不同的资源。
  
42-谨防因构造函数抛出异常发生的问题
  解决方法，在构造函数中使用try catch，catch中释放资源对象。
  或者使用智能指针。
  或者写两个函数init和release分别给构造函数和析构函数调用。

43-多态基类的析构函数应该为虚。
  不要继承string等类或者STL容器因为它们大多析构函数是非虚的会造成部分析构的情况造成内存泄露。
  为了保证多态子类在释放时不会因为基类指针造成部分析构，我们应当把具有virtual函数的基类的析构函数设为virtual以保证全析构。

44-绝不让构造函数为虚
  构造函数需要知道对象的具体类型，并且你无法获取构造函数的指针。因为在调用构造函数前，内存中没有虚函数表，所以如果构造函数为
  虚必定出错。
  
45-避免在构造、析构函数中调用虚函数
  构造和析构顺序导致你调用的虚函数所属的对象还未在内存中创建，这样会调用错误的函数。
  
46-默认参数在构造函数中给你带来的喜与悲
  可以减少代码冗余，但是要注意重载造成潜在的问题。

47-区分overloading overriding hiding的差异
  overloading重载：同一作用域的同名函数，参数列表不同。
  overriding重写：派生类中对基类中的虚函数重新实现，函数名和参数完全相同。
  hiding隐藏：派生类中函数屏蔽了基类中的同名非虚函数。
  
48-重载operator=的标准三步走
  检查自赋值
  释放原有空间。开辟新空间。复制。
  return *this
  
49-运算符重载，是成员函数还是友元函数
  不可以臆造运算符
  运算符原有的操作数个数、优先级和结合性不能改变
  操作数中至少一个是自定义类型
  保持重载运算符的自然含义
  
  双目运算符推荐友元方式重载（除了赋值），单目运算符推荐成员函数方式重载（除了函数调用，下标和->）。
  流运算符重载应当为friend

50-有些运算符应该成对出现

51-特殊的自增自减运算符
  T& operator++()前缀
  const T operator++(int)后缀

52-不要重载&& || ，
  无法模仿短路效果

53-合理地使用inline函数来提高效率
  
54-慎用私有继承
  
55-抵抗MI多重继承的糖衣炮弹

56-提防对象切片
  
  
50-
  
  
